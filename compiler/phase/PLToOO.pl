/*
	Generates the code for the SAE program.

	@author Michael Eichberg
*/
:- module('Compiler:Phase:PLtoOO',[pl_to_oo/4]).

:- use_module('../Predef.pl').
:- use_module('../Utils.pl').
:- use_module('../Debug.pl').



/* Encoding of the SAE Prolog program in the Abstract OO Language.

	@param Debug the list of debug information that should be printed.
	@param PLProgram is the program in normalized form. The structure is:
		<pre>
		[	pred(
				a/1, 							% The identifier of the predicate
				[(C, [det, type=int])],	% A list of clauses defining the 
												% predicate. C is one of these clauses.
												% In case of built-in propeties, this list
												% is empty.
				[type=...]					% List of properties of the predicate
			),...
		]
		</pre>
	@param OOProgram is the result of transforming the Prolog Program to an 
		Abstract OO Language (AOOL) Program.
		
*/
pl_to_oo(Debug,PLProgram,_OutputFolder,OOProgram) :-
	debug_message(
		Debug,on_entry,
		'\nPhase: Transforming to an Abstract Object-oriented Program___________'),

	encode_predicates(Debug,PLProgram,OOProgram).




encode_predicates(Debug,PLProgram,OOProgram) :-
	encode_predicates(Debug,PLProgram,PLProgram,OOProgram).



encode_predicates(_Debug,[],_PLProgram,[]).
encode_predicates(
	Debug,
	[pred(Functor/Arity,Clauses,PredicateProperties)|Predicates],
	PLProgram,
	OOProgram
) :-
	(
		Clauses = [_|_], % we only need to encode user-defined predicates...
		debug_message(Debug,processing_predicate,['Processing: ',Functor,'/',Arity]),
		OOProgram = [P|Rest],
		encode_predicate(Functor/Arity,PredicateProperties,Clauses,PLProgram,P)
	;
		Clauses = [], % it is a built-in predicate
		OOProgram = Rest
	),
	encode_predicates(Debug,Predicates,PLProgram,Rest).
	
	


predicate_implementation_class(PredicateName,ClassName) :-
	atomic_list_concat([PredicateName,'P'],ClassName).



predicate_meta_information_singleton(PredicateName,SingletonName) :-
	atomic_list_concat([PredicateName,'M'],SingletonName).
	

	
multi_line_comment(AtomicList,comment(Text)) :-	
	atomic_list_concat(AtomicList,Text).

	

encode_predicate(Functor/Arity,PredicateProperties,Clauses,PLProgram,E) :-
	atomic_list_concat([Functor,Arity],PredicateName),
	predicate_implementation_class(PredicateName,PredicateImplementation),
	predicate_meta_information_singleton(PredicateName,PredicateMetaInformation),
	term_to_atom(PredicateProperties,PredicatePropertiesAtom),
	multi_line_comment(
		[
			'Generated by SAE Prolog\n\n',
			'Predicate:\n',
			'\t',Functor,'/',Arity,'\n',
			'Properties:\n',
			'\t',PredicatePropertiesAtom
		],
		PredicateComment
	),
	E = pred(
		Functor/Arity,
		[
			PredicateComment,
			namespace(
				'sae',
				[	% members of the namespace
					singleton(
						final(yes),
						PredicateMetaInformation,
						none, % extends..
						[
							field_declaration(final(yes),'theFunctor',btype(stringAtom),string_atom(Functor)), % btype <=> built_in type
							method_declaration(
								public, % visibility: private or public
								'functor', % name of the method
								signature([],btype(stringAtom)), 
								[return(get_field(this,'theFunctor'))] % list of statements
							),
							method_declaration(
								public, % visibility: private or public
								'arity', % name of the method
								signature([],ptype(int)), 
								[return(constant_int(Arity))] % list of statements
							),
							META_CALL_SUPPORT_METHOD
						]
					),
					class( % a class declaration
						final(yes),
						PredicateImplementation,
						btype(solutions), % extends
						[	
							field_declaration(final(no),'commit',ptype(boolean),constant_boolean(false)), % ptype <=> primitive type
							field_declaration(final(no),'currentClause',ptype(int),constant_int(1)),
							field_declaration(final(no),'currentGoal',ptype(int),constant_int(0)),
							field_declaration(final(no),'goalStack',btype(goalStack),empty_goal_stack),
							
							constructor_declaration( % DUMMY
								[parameter('a1',btype(term)),parameter('a2',btype(term))],
								[
									set_field(this,'a1',get_lv('a1'))
								]
							),
							NEXT_SOLUTION_METHOD
						]
					)
				]
			)
		]),
	encode_meta_call_support(Arity,PredicateImplementation,META_CALL_SUPPORT_METHOD),
	encode_next_solution_method(Clauses,NEXT_SOLUTION_METHOD)
	.


encode_meta_call_support(Arity,PredicateImplementation,META_CALL_SUPPORT_METHOD) :-
	META_CALL_SUPPORT_METHOD = method_declaration(
		public, % visibility: private or public
		'apply', % name of the method
		signature([parameter('as',btype(array(btype(term))))],btype(solutions)), 
		Statements 
	),
	Statements=[
		return(new(utype(PredicateImplementation),Arguments))
	],
	from_0_to_X(Arity,load_from_array(get_lv(as)),Arguments).


/*
	@param Array a simple expression with type "array(_)".
*/
load_from_array(Array,Index,Instr) :-
	Instr = load_from_array(Array,constant_int(Index)).




%%%%%% TODO
encode_next_solution_method(Clauses,NEXT_SOLUTION_METHOD) :-
	NEXT_SOLUTION_METHOD = method_declaration( % DUMMY
		public, % visibility: private or public
		'next', % name of the method
		signature([],ptype(boolean)), 
		[return(constant_boolean(false))] % list of statements
	).




/*
	For each integer value J in the range [I..X) F is called with J and O (for storing the output)
	as additional arguments. The values bound to the "O"s are collected and
	"returned" as a list.
*/
from_0_to_X(X,F,R) :- from_i_to_X(0,X,F,R).
from_i_to_X(X,X,_F,[]) :- !.
from_i_to_X(I,X,F,[O|R]) :- 
	I < X,!,
	call(F,I,O),
	NewI is I + 1,
	from_i_to_X(NewI,X,F,R).
	


	
/* COMPILING CUT IN THE PRESENCE OF OR...	

?- (write(0);write(1)),(write(a),!) ; write(b).
0a
true.

?- A=f,(write(0);write(1)),((A=t,write(a),!) ; write(b)).
0b
A = f ;
1b
A = f.

*/

	
