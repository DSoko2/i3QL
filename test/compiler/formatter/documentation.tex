\documentclass{article}
\usepackage[english, ngerman]{babel}
\usepackage[stable]{footmisc}
\usepackage{ucs} 
%\usepackage[utf8]{inputenc} 
\usepackage{longtable}
\usepackage{soul}
\usepackage{color}
\usepackage{multirow}
\usepackage[dvipdfm]{geometry}
\usepackage{rotating}
\usepackage[font={footnotesize,it},center,aboveskip=0em,belowskip=0em]{caption}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{paralist}
\usepackage{amsmath}
\usepackage{float}
\usepackage[english,hyperfootnotes=false]{hyperref}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{pgfplots}
\usepackage{lscape}
\usepackage{caption}
\usepackage{subcaption}

% Textbreite
\setlength{\textwidth}{17.2cm}

% Textanfang vom linken Rand
\setlength{\oddsidemargin}{0.5cm}

\lstset{ %
language=Prolog,
%showspaces=true,               % show spaces adding particular underscores
%showstringspaces=true,         % underline spaces within strings
showtabs=true         
}

\begin{document}
 \selectlanguage{english}
 
\section{Formatting and Beautifying (ISO) Prolog} 
 \subsection{Test environment}
 The test environment is used as starting point to specify the different possible formattings for Prolog code. Based on this decisions, the test cases were build to guarantee the correctness of the formatter and as consequence the correctness of the produced code. Of course, the code has to be semantically and syntactic correct. Otherwise a formatter would be useless.  Next, different scenarios are illustrated on the left-hand side and their corresponding formatted code on the right-hand side. On every example code of formation on the right-hand side, every formation in use is used.
 
 
\begin{figure}[h]
Starting with an empty set of code, the formatter naturally should not add anything and left the blank line.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/EmptyTest.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/EmptyTest_formatted.pl}
\end{minipage}

\caption{Formatting empty lines}
\label{lst:empyt}
\end{figure}

 
\begin{figure}[h]
For better readability there should be some white spaces around an operator, as you can see around + and = in the following figure \ref{lst:operatorWhitespaces}.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/OperatorsWhitespace.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/OperatorsWhitespace_formatted.pl}
\end{minipage}

\caption{Formatting white spaces around operators}
\label{lst:operatorWhitespaces}
\end{figure}
 
 
\begin{figure}[h]
But if a comma is used for a set of arguments, different variations of white spaces could be confusing. We reduce needed white spaces to a minimum and clear all useless ones, as illustrated in \ref{lst:complextTermWhitspace}. Of course an already optimal code should not become worse.\\


\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Whitespace_in_compound_terms.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Whitespace_in_compound_terms_formatted.pl}
\end{minipage}

\caption{Formatting whitespaces in complex terms}
\label{lst:complextTermWhitspace}
\end{figure}



\begin{figure}[h]
Lists are more a complex topic and is handled different among programmers. Figure \ref{lst:lists} shows a set of formations for lists. They always result in a style like [a,b$|$rest]. If the rest is empty, we can drop it.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Lists.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Lists_formatted.pl}
\end{minipage}

\caption{Formatting lists}
\label{lst:lists}
\end{figure}


\begin{figure}[h]
Also white spaces in lists can occur but of course reduce readability as well. Figure \ref{lst:listWithesaces} shows the corresponig scenario and the formatted solution.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Whitespace_in_lists.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Whitespace_in_lists_formatted.pl}
\end{minipage}

\caption{Formatting white spaces in lists}
\label{lst:listWithesaces}
\end{figure}



\begin{figure}[h]
If the comma is used as an \& operator, it has to be formatted in another way to see the difference to a simple enumeration of parameters. Due to this fact, commas as functors have a white space behind them as illustrated in figure \ref{lst:comma}.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Comma_as_functor.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Comma_as_functor_formatted.pl}
\end{minipage}

\caption{Formatting comma as a functor}
\label{lst:comma}
\end{figure}


\begin{figure}[h]
To be able to distinguish the different clauses and their possible different arity figure \ref{lst:sameclause_arity} shows that there should not be any empty line between same clauses with the same arity.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/NoEmptyLines.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/NoEmptyLines_formatted.pl}
\end{minipage}

\caption{Formatting empty lines between same clause with same arity}
\label{lst:sameclause_arity}
\end{figure}

\begin{figure}[h]If the arity is different but the clauses is again the same, we introduce only one empty line between them as mentioned in figure \ref{lst:sameclauses}.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/LineBetweenSameClauses.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/LineBetweenSameClauses_formatted.pl}
\end{minipage}

\caption{Formatting empty lines between same clauses with different arity}
\label{lst:sameclauses}
\end{figure}

\begin{figure}[h]
Finally, if there are to different clauses, we separate them with two empty lines as you can see in figure \ref{lst:diffclauses}.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/TwoLineBetweenDiffClauses.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/TwoLineBetweenDiffClauses_formatted.pl}
\end{minipage}

\caption{Formatting empty lines between different clauses}
\label{lst:diffclauses}
\end{figure}

\begin{figure}[h] A very important topic are brackets in Prolog to see which operator is at first and has a higher priority. Based on simple mathematics, the next scenario handles this problem. Naturally, multiplication has a higher priority than addition in mathematics, if the addition is not in brackets. On the other hand useless brackets can be dropped. Both test cases are illustrated in figure \ref{lst:operator_brackets}.\\

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/OperatorBrackets.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/OperatorBrackets_formatted.pl}
\end{minipage}

\caption{Formatting needed brackets around operators}
\label{lst:operator_brackets}
\end{figure}

\begin{figure}[h]

\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/If_then_else.pl}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/If_then_else_formatted.pl}
\end{minipage}

\caption{Formatting or statements}
\label{lst:or}
\end{figure}

\begin{figure}[h] The last topic is line break. When a line reaches the default or user-set linewidth the clause has to be split to several lines. Three cases are possible. First, the line fits into the line lenght. Second the line willbe split after the :- and it will be checked if clause body and head are both fit in their lines. Last the clause will be split after the :- and at every AND (,) in the body \ref{lst:line_break}.\\

\begin{minipage}{1\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Line_Break.pl}
\end{minipage}

\begin{minipage}{1\textwidth}
\lstinputlisting{Parser/test/compiler/formatter/data/Line_Break_formatted.pl}
\end{minipage}

\caption{Formatting needed brackets around operators}
\label{lst:line_break}
\end{figure}
% \bibliographystyle{alpha}
% \bibliography{ref}
% \nocite{} % show all bibliography entries}

\end{document}