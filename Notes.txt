TODOs:

0)
- Complete the support for "or"
- ground, atom, number (in the compiler)
- length
- is_list
- memberchk
- arg
- functor
- =..
- atom_codes
- call
- findall


1)
completely support all standard control-flow predicates: 
	C -> T ; E
	C *-> T ; E
	C -> B
	C *-> B (this is the same as "and")
are not yet supported.
Idea: implement these control-flow predicates by using "artificial goals" to
implement the condition-local cut.

2)
Implement functionality to test and extract values from terms if possible (instead of unifying)

3)
Implement more complete support for last call optimization (e.g., to support the integers predicate of primes)

4) 
Type specialization

5)
Analyze predicates to determine how many solutions will be generated at runtime
(can help to scale the "tak" benchmark)

6)
(If necessary) Add a method to the goal interface that enables the caller of a
predicate to identify the number of further solutions (e.g. a method hasMore() 
where the answers are: No, Maybe, Yes)


How to use the compiler:

make,compile('benchmarks/einsteins_riddle.pl','build/src/java/'),compile('benchmarks/hanoi.pl','build/src/java/'),compile('benchmarks/primes.pl','build/src/java/'),compile('benchmarks/qsort.pl','build/src/java/'),compile('benchmarks/queens.pl','build/src/java/'),compile('benchmarks/tak.pl','build/src/java/'),compile('benchmarks/ancestor.pl','build/src/java/'),compile('benchmarks/chat_parser.pl','build/src/java/'),compile('benchmarks/nrev.pl','build/src/java/'),compile('benchmarks/zebra.pl','build/src/java/').

