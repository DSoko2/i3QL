% Optimized queries over in-memory collections
% Paolo G. Giarrusso, Klaus Ostermann
<!-- % An embedded language for optimizable incremental queries over in-memory collections -->
\newcommand{\intersect}{\wedge}

# Meta infos
This project, variously called LINQ on Steroids, IVM, and part of The Project\ (™), implements Incremental View Maintenance (IVM) for views on in-memory collections. It is related to projects presented at ECOOP from students of James Noble.

It could be nice to integrate this with some (transparent) support for persistence (orthogonal persistence?), like Hibernate, to get an embedded database library. If a remoting library could then support remote clients, we would then have a complete DBMS. However, numerous research challenges exist for something like this.

# A new take on the presentation
## Introduction
Typical programs perform repetitive work, and thus contain computations over collections of some form; in particular, they produce new collections from existing ones, and thus perform _queries_. Research in query processing in database has identified many optimizations which afford great speedups, from high-level restructuring to index application and incremental view maintenance, yet the typical program does not take advantage of them for processing over in-memory collection, because performing these optimizations by hand leads to a complex, error-prone and hard-to-maintain restructuring of the original program. Scala offers operators like map, flatMap, withFilter and union, which are present in different form in many functional languages, together with for comprehensions, similar to list comprehensions in other languages: they are a form of syntactic sugar for accessing map, flatMap and withFilter. We consider these operators to form a DSEL for queries over collection. In our work, we reimplement this DSEL to allow optimization of queries, and we implement a few significant ones. We first design and implement a deep embedding of a portion of this DSEL. On top of this deep embedding, we implement some simple optimizations as a first step.
We evaluate our work.

Further work (just started):
- incremental view maintenance
- XXX

# Introduction
Many computations in typical programs operate over collections and extract informations from them. Higher-order operators allow formulating many such computations as queries; we can also say that a collection library provides a DSEL of queries over collections. It is often desirable to optimize execution of queries using a variety of approaches. For instance, some queries are often re-executed after changes on the original collections; other queries might be executed faster by maintaining additional data structures, like indexes over the original collections; yet other queries might be executed faster simply by restructuring the query before execution. We propose a deeply-embedded Scala DSEL for expressing queries over in-memory collections with the following desirable properties:

- the query language is based on a hierarchical data model and the associated monadic query language, like the one used for Scala for comprehension, and similarly to the one described by Meijer and Biederman (2011) and Fegaras and Maier (2000)
- queries are expressed using for comprehensions
- queries can be interpreted with a very small overhead compared to queries expressed directly using Scala’s collection library
- queries can have, as results, both Traversable, Set and Map (support for Seq should be possible, too)
- our embedding techniques (we are embedding monadic operations over queries) extends the techniques used in the Scala collection library ([Fighting Bitrot with Types]) and allows, without code duplication, to have very specific types for the result of different operations; flatMap on a Map will return a Map, and on a Set will return a Set, and so on.
- results of queries over mutable collections are incrementally updated when the original collection changes.
- indexes can be generated and applied - they are simply queries of type Map[A, B], which are updated thanks to same support for IVM as other query results. This is only possible because our data representation allows to also represent different kinds of collections uniformly.
- queries can be optimized before execution; the optimized queries, unlike in SQL, can still be expressed in the same language
- we embed a significant subset of pure Scala, and identify problems which prevent using (?)
- the complete pure subset of Scala can be used in the queries (? - elaborate), except function calls (…) and pattern matching and …
- we have a partial emulation of expression trees in Scala through implicit conversions, and suggest approaches to extend the covered Scala subset.

Incremental maintenance of the results of flatMap is a novel algorithm. (XXX: still need to take care of memory and garbage collection).

Our contributions are as follows:
- index are identified with materialized views representing dictionaries, and can be used explicitly; this simplifies query optimization
- our embedding supports both Traversable, Set and Map with appropriate types
- the architecture used to implement IVM on expression trees is novel
- we are the first to support Incremental View Maintainance for FlatMap operations

# Our query language: first-class indexes considered helpful
Query languages for relational and OO databases allow to program queries declaratively, and optimizers transform those queries into execution plans for efficient execution.
Optimizers however often fail optimizing a query to an efficient execution plan: In this case, developers modify their queries to a different form until the results of optimization are the expected ones.
Disadvantages are:
- Understanding the output of optimization requires understanding a different language than SQL.
- The optimizer has access to ‘built-in functions’ which the programmer cannot use.
- Producing the desired execution plan might in general be impossible. Since the result of optimization is expressed in a quite different form, it is impossible to write directly an execution plan.
The reason for this is that execution plans contain many low-level details, with which the developer should have nothing to do.

We maintain that as many optimizations as possible should produce a program in the same language, that is, it should be _closed_. To this end, we introduce a query language embedded in Scala based on for-comprehensions, where indexes are first-class entities like tables. Transformation of queries done to benefit from indexing becomes then a closed transformation, which can be done either automatically or manually.
We do not maintain that *all* optimizations should be accessible to the suer. However, it should be possible to at least perform transformations which change the time complexity of queries.
That is why in our proposal, indexes are made part of the logical level and become therefore accessible.

Our prototype implementation supports only in-memory collections, but this already allows showing the potential of the language.

<!-- Problem: what happens for e.g. join order? We usually want to keep that to be decided by the database -->
This situation resembles logic programming: a declarative approach is proposed, but efficient execution demands manual optimizations which break the elegance of the original model.
Functional programming languages, on the other side, allow expressing the intent in a clear way which also lends itself to reasonably efficient execution (compared to logic programming) and to further optimizations.

<!-- Is this regularity? -->

# Representing indexes: The groupBy operator
Indexes do not require special support; they are encoded through the `groupBy` operator. A query of the form:

    coll filter (x => f(x) == y)

is semantically equivalent to a query which builds an index first with the result of applying `f` to elements of `coll`, and then selecting the entry for `y`:
<!--can be executed as a lookup on an query building an index first:-->

    coll groupBy f apply y

What the optimizer does is (a variant of common subexpression elimination) between the resulting query and the keys of a map existing precomputed expressions.
A repository contains a map from queries to their evaluated results (XXX: it should be incrementally maintained queries!).

# A few running examples:

Example 1 - a join expressed through a set comprehension, as a filtered Cartesian product (expressed through flatMap):

~~~
for (i <- coll1;
      j <- coll2;
      if i.field1 === j.field2)
  yield (i, j)
~~~

Example 2 - a Cartesian product query which cannot be transformed into a join - it could be manually rewritten though:

~~~
for (i <- coll1;
      j <- coll2;
      if i.foo + j.bar === 3)
  yield (i, j)
~~~

Example 3 - a query which could not be expressed as a Cartesian product:

~~~
for (i <- coll1;
      j <- i.divisors;
      if i.foo + j.bar === 3)
  yield (i, j)
~~~

# Operators
## Higher-order operators from relational algebra
- Join: can be expressed through flatMap, which can be executed directly (similarly to a nested-loop join), but also through a special join node.
- Selection: becomes withFilter
- Projection: becomes map
- Rename: makes less sense as such, becomes map as well

- Aggregation: becomes fold (still to implement)
## First-order basic operators from relational algebra
- Set union: cannot be expressed through other operators
- Set difference can be expressed in the base language through withFilter and forall (in time O(N^2)), but also with a specific, direct operator, which can be executed similarly to an anti-join.
- Set intersection: can be expressed through set difference ($A \intersect B = A - (A - B)$) or through a join.
but probably should be expressed directly, not through other operators.

Set intersection and set difference allow unseating collections built within withFilter operations.

It could be useful to have a let operation to support directly hoisting out of loops.
## Other kinds of joins
Semi-joins, anti-joins.
## IVM properties
Set union, selection and mapping are completely self-maintainable: that is, not even the result is needed for self-maintenance.
Tables used in filters, instead, must be materialized to allow self-maintenance; the result, again, is not needed.
flatMap is more complex. Results of flatMap require instead to store part of the results.

# Related work
An embedding of Scala within itself is Lightweight modular staging and language virtualization.
Techniques for embedding operations on Scala collections are also used for e.g. Scala Integrated Query, a Scala DSEL for queries to SQL databases expressed using for comprehensions and additional operators. Their data model however only considers one type of collections, represented by the interface Iterable, because different types are not necessary for queries on SQL databases (relational algebra does not support different ways to group records, only different records). Our language embedding allows expressing  looks more suitable for CoSQL databases.

"A Recursive Algebra for Nested Relations" defines a data-model similar to ours, because it is also compositional.

(Verify) Various techniques can be seen as allowing representing dictionaries. For instance, a JSON object is a dictionary; since JSON and XML are "similar", one can argue that even XML allows representing dictionaries, especially when those techniques are used in a semi-structural context where no fixed schema is imposed. However, indexes are in a sense _reverse_ maps, and thus are different.

In a relational database, a relation is actually also a dictionary, mapping a value of the primary key to the whole record; however, the language does not explicitly allow using a relation as a dictionary; moreover, there is no uniform way to refer to both relations and indexes.

Ferry is also a functional language for data queries, but it is implemented by translation to SQL; moreover, they do not have a concept of first-class dictionaries or indexes - XXX develop a stronger comparison.

Henglein, Larsen (2010), in "Generic Multiset Programming for Language-integrated Querying", present an alternative framework which allows implementing some of the same optimizations we present. In their development however the users are supposed to write the functions used for queries explicitly using operators exposing their structure. In our case, instead, we emulate expression trees to allow the same optimization to be still possible with less involvement of the user. Their model does not reify the queries, preventing their optimization to happen before execution time - this is sensible for the limited optimizations they implement, but not in general. Lazy products, on the other hand, are indeed an interesting idea which we do not support (XXX: should we?).
