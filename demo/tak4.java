// Generated by SAE Prolog - www.opal-project.de
package predicates;

import saere.*;
import static saere.term.TermFactory.*;

public final class tak4 implements Solutions {

    public final static PredicateIdentifier IDENTIFIER = new PredicateIdentifier(
	    StringAtom.instance("tak"), 4);

    public final static PredicateFactory FACTORY = new NArgsPredicateFactory() {
	@Override
	public Solutions createInstance(Term[] args) {
	    return new tak4(args[0], args[1], args[2], args[3]);
	}
    };

    public static void registerWithPredicateRegistry(PredicateRegistry registry) {
	registry.register(IDENTIFIER, FACTORY);
    }

    private int clauseToExecute = 1;
    private Solutions clauseSolutions;
    private int goalToExecute = 1;
    private boolean cut = false;

    private final Term arg0;
    private final Term arg1;
    private final Term arg2;
    private final Term arg3;

    public tak4(final Term arg0, final Term arg1, final Term arg2, final Term arg3) {
	this.arg0 = arg0.unwrapped();
	this.arg1 = arg1.unwrapped();
	this.arg2 = arg2.unwrapped();
	this.arg3 = arg3.unwrapped();
    }

    public boolean next() {
	switch (clauseToExecute) {
	case 1: {
	    if (c1()) {
		return true;
	    } else if (cut) {
		return false;
	    } else {
		clauseToExecute = 2;
		goalToExecute = 1;
	    }
	}
	case 2: {
	    return c2();
	}

	default:
	    throw new Error();
	}
    }

    private boolean c1() {
	switch (goalToExecute) {
	case 1: {
	    Term X = arg0;
	    Term Y = arg1;
	    Term Z = arg2;
	    Term A = arg3;

	    clauseSolutions = and(
		    and(compoundTerm(StringAtom.instance("=<"), X, Y), StringAtom.CUT_FUNCTOR),
		    unify(Z, A)).call();
	    goalToExecute = 2;
	}
	case 2: {
	    boolean succeeded = clauseSolutions.next();
	    if (succeeded)
		return true;
	    cut = clauseSolutions.choiceCommitted();
	    clauseSolutions = null;
	    return false;
	}
	default:
	    throw new Error();
	}
    }

    private boolean c2() {
	switch (goalToExecute) {
	case 1: {
	    Term X = arg0;
	    Term Y = arg1;
	    Term Z = arg2;
	    Term A = arg3;
	    Variable X1 = variable();
	    Variable A1 = variable();
	    Variable Y1 = variable();
	    Variable A2 = variable();
	    Variable Z1 = variable();
	    Variable A3 = variable();
	    clauseSolutions = and(
		    and(and(and(
			    and(and(compoundTerm(StringAtom.IS_FUNCTOR, X1,
				    compoundTerm(StringAtom.MINUS_FUNCTOR, X, atomic(1))),
				    compoundTerm(StringAtom.instance("tak"), X1, Y, Z, A1)),
				    compoundTerm(StringAtom.IS_FUNCTOR, Y1,
					    compoundTerm(StringAtom.MINUS_FUNCTOR, Y, atomic(1)))),
			    compoundTerm(StringAtom.instance("tak"), Y1, Z, X, A2)),
			    compoundTerm(StringAtom.IS_FUNCTOR, Z1,
				    compoundTerm(StringAtom.MINUS_FUNCTOR, Z, atomic(1)))),
			    compoundTerm(StringAtom.instance("tak"), Z1, X, Y, A3)),
		    compoundTerm(StringAtom.instance("tak"), A1, A2, A3, A)).call();
	    goalToExecute = 2;
	}
	case 2: {
	    boolean succeeded = clauseSolutions.next();
	    if (succeeded)
		return true;
	    // choiceCommitted = clauseSolutions.choiceCommitted();
	    clauseSolutions = null;
	    return false;
	}
	default:
	    throw new Error();
	}
    }

    @Override
    public void abort() {
	clauseSolutions.abort();
	clauseSolutions = null;
    }

    @Override
    public boolean choiceCommitted() {
	return false;
    }
}
